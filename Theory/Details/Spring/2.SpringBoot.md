### AGENDA

1. [Spring boot components](#spring-boot-components)
2. [Advantage of spring boot](#advantage-of-spring-boot)
3. [Different tier](#different-tiers)
4. [Annotation](#annotations)
5. [Basic program](#basic-program)
6. [ResponseEntity and ResponseStatusException](#responseentity-and-responsestatusexception)
7. [Validation in spring boot](#validation-in-spring-boot)
8. [Custom Exceptional Handling](#custom-exceptional-handling)

Spring Boot = spring framework + prebuilt configuration + Embedded server

#### Spring boot components

* Spring Boot Starters
* Auto Configuration
* Spring Boot Actuator-monitor the application
* Embedded Server
* Spring Boot DevTools

#### Advantage of spring boot

1. Stand alone and Quick Start
2. Starter code
3. Less Configuration
4. Reduce cost and application development time

#### Different Tiers

* Presentation Layer—User access. Controller classes exist.
* Service Layer—Business logic. communicating b/w user and data.
* Data access Layer - Repository classes exit.

![SpringBootArchiteture.jpg](..%2F..%2Fresources%2FSpringBootArchiteture.jpg)

#### Annotations

* @RestController - above the controller class having all get and post request
* @GetMapping("</url>")
* @PostMapping("</url>)
* @PathVariable - read data from url like String name. This is coming in argument
* like helloget(@PathVariable String name)
* @RequestBody - read data of post-body like string name — this is coming in argument
* like helloPost(@RequestBody String message)
* JSON Response—create pojo and in return of controller method called object
* @DeleteMapping("</url>")
* @PutMapping("</url>") - update
* @RequestMapping()
  > //@GetMapping("/api/admin/category")
  @RequestMapping(value="/api/admin/category",method = RequestMethod.GET)
  public ResponseEntity<List<Category>> createCategory() {
  return new ResponseEntity<>(categoryService.getCategories(),HttpStatus.OK);

  }

> @RequestMapping("/api/admin") all maping over class to dd common path

* @Service - on service impl class
* @Entity - change class to entity. Spring boot will create table same as class name
* @ID - Make object as a primary key in table

#### Basic Program

#### Controller

```java

@RestController()
public class CategoryController {
    @Autowired
    public CategoryService categoryService;

    //Create Category
    @PostMapping("/api/admin/createCategory")
    public String createCategory(@RequestBody Category category) {
        return categoryService.createCategory(category);
    }

    //Delete Category
    @DeleteMapping("/api/admin/deleteCategory/{id}")
    public String deleteCategory(@PathVariable int id) {
        return categoryService.deleteCategory(id);
    }
    //Update Category

    //Get All category
    @GetMapping("/api/admin/category")
    public List<Category> createCategory() {
        return categoryService.getCategories();

    }
}
```

Service

```java
public interface CategoryService {


    public List<Category> getCategories();

    public String createCategory(Category category);

    public String deleteCategory(int id);
}

```

ServiceImpl

```java

@Service
public class CategoryServiceImpl implements CategoryService {

    public List<Category> categories = new ArrayList<Category>();
    private int nextId = 1;

    public List<Category> getCategories() {
        return categories;
    }

    public String createCategory(Category category) {
        category.setId(nextId++);
        categories.add(category);
        return "Category created successfully";
    }

    public String deleteCategory(int id) {
        Category category = categories.stream().filter(c -> c.getId() == id).findFirst().orElse(null);
        if (category == null) {
            return "Category not found";
        } else {
            categories.remove(category);
            return "Category deleted successfully";
        }
    }
}
```

Category

```java
public class Category {
    private int id = 1;
    private String categoryName;

    public Category(int id, String categoryName) {
        this.id = id;
        this.categoryName = categoryName;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getCategoryName() {
        return categoryName;
    }

    public void setCategoryName(String categoryName) {
        this.categoryName = categoryName;
    }
}
```

[Home](#agenda)

#### ResponseEntity and ResponseStatusException

ResponseStatusException

````java
public String deleteCategory(int id) {
//        Category category = categories.stream().filter(c->c.getId()==id).findFirst().orElse(null);
//        if(category==null){
//            return "Category not found";
//        }else {
//            categories.remove(category);
//            return "Category deleted successfully";
//        }

    Category category = categories.stream().filter(c -> c.getId() == id).findFirst().orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Category not found"));
    categories.remove(category);
    return "Category deleted successfully";
}
````

#### ResponseEntity

```java

@DeleteMapping("/api/admin/deleteCategory/{id}")
public ResponseEntity<String> deleteCategory(@PathVariable int id) {
    try {
        return new ResponseEntity<String>(categoryService.deleteCategory(id), HttpStatus.ACCEPTED);
    } catch (ResponseStatusException e) {
        return new ResponseEntity<String>(e.getMessage(), e.getStatusCode());
    }
}
```

```java

@RestController()
public class CategoryController {
    @Autowired
    public CategoryService categoryService;
    //Create Category
    @PostMapping("/api/admin/createCategory")
    public ResponseEntity<String> createCategory(@RequestBody Category category) {
        return new ResponseEntity<String>(categoryService.createCategory(category), HttpStatus.CREATED);
    }

    //Delete Category
    @DeleteMapping("/api/admin/deleteCategory/{id}")
    public ResponseEntity<String> deleteCategory(@PathVariable int id) {
        try {
            return new ResponseEntity<String>(categoryService.deleteCategory(id), HttpStatus.ACCEPTED);
        } catch (ResponseStatusException e) {
            return new ResponseEntity<String>(e.getMessage(), e.getStatusCode());
        }
    }

    //Update Category
    @PutMapping("/api/admin/updateCategory/{id}")
    public ResponseEntity<String> updateCategory(@PathVariable int id, @RequestBody Category category) {
        return new ResponseEntity<String>(categoryService.updateCategory(id, category), HttpStatus.OK);
    }

    ;

    //Get All category
    @GetMapping("/api/admin/category")
    public ResponseEntity<List<Category>> createCategory() {
        return new ResponseEntity<>(categoryService.getCategories(), HttpStatus.OK);

    }
}
```

[Home](#agenda)
#### Validation in spring boot

Field level annotations:

* @NotNull - this annotation we add at pojo above the field. and to give user coorect message add @Valid in controler
  inside argument

```java

@NotNull
private String categoryName;

@PostMapping("/createCategory")
public ResponseEntity<String> createCategory(@Valid @RequestBody Category category) {
  return new ResponseEntity<String>(categoryService.createCategory(category), HttpStatus.CREATED);
}
```

* @NotEmpty
* @Size(min=x,max=y)
* @Email
* @Min(value)
* @Max(value)

Above annotation with different ways to send error message in case of validation failed

```
@NotEmpty(message="Please enter category.Field can't be blank")
@Size(min=2, max=15)
@Size(min = 2)
@Size(min = 2, message="Please enter minimum 5 character")
```

[Home](#agenda)

#### Custom Exceptional Handling

> The **@RestControllerAdvice** with **@ExceptionHandler** automatically catches and handles exceptions thrown by any
> controller in your Spring application

* @RestControllerAdvice - this is a class level annotation
* @ExceptionHandler - this is a method level annotation having class as an argument

```java

@RestControllerAdvice
public class GlobalException {

  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<HashMap<String, String>> methodArgumentNotValidException(MethodArgumentNotValidException e) {
    HashMap<String, String> errors = new HashMap<>();
    e.getBindingResult().getAllErrors().forEach((error) -> {
      String fieldName = ((FieldError) error).getField();
      String errorMessage = error.getDefaultMessage();
      errors.put(fieldName, errorMessage);
    });


    return new ResponseEntity<>(errors, HttpStatus.FOUND);
  }
}
```

Creating own custom Exception

1. create a Class thats extends RuntimeException and contain pojo and constuctor
2. add that class in GlobalException. to handle from one place
3. Call the class in service to set values of POJO

1. create a Class thats extends RuntimeException and contain pojo and constuctor

```java
public class ResourcesNotFound extends RuntimeException {

  private String resourceName;
  private String fieldName;
  private Long fieldId;
  private String message;

  public ResourcesNotFound() {

  }

  public ResourcesNotFound(String resourceName, String fieldName, String message) {
    super(String.format("%s not found with %s: %s", resourceName, message, fieldName));
    this.resourceName = resourceName;
    this.fieldName = fieldName;
    this.message = message;

  }

  public ResourcesNotFound(String resourceName, Long fieldId, String message) {
    super(String.format("%s not found with %s: %d", resourceName, message, fieldId));
    this.resourceName = resourceName;
    this.fieldId = fieldId;
    this.message = message;

  }
}
```

2. add that class in GlobalException. to handle from one place

```java

@ExceptionHandler(ResourcesNotFound.class)
public ResponseEntity<String> resourceNotFound(ResourcesNotFound e) {

  return new ResponseEntity<String>(e.getMessage(), HttpStatus.NOT_FOUND);
}
```

3. Call the class in service to set values of POJO

```java
Category category = categories.stream().filter(c -> c.getId() == id).findFirst()
        .orElseThrow(() -> new ResourcesNotFound("Category", Long.valueOf(id), "Category ID"));

```

[Home](#agenda)

#### DTO

- Data transfer object — Design pattern used to transfer the data between software application subsystems
- Decoupling—Separate response from Model. so if we add anything in database then my request object will not impacted
  unless we want it to be impacted.
- Example. if we add model directly in controller, then adding column (create_date) will change my request body. Thats
  why we need a mapper which decouple database table and request body
- Customised the response object. If we dont use DTO then all column present in model will come in a response. which is
  not good sometime like password.

> JSON <- DTO <- Model(Entity)
![DTO Architecture.jpg](..%2F..%2Fresources%2FDTO%20Architecture.jpg)